const express = require("express");
const http = require("http");
const socketIo = require("socket.io");
const cors = require("cors");
const fs = require("fs");
const path = require("path");

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
   cors: {
      origin: "*",
      methods: ["GET", "POST"],
   },
});

app.use(cors());
app.use(express.json());

// –•—Ä–∞–Ω–∏–ª–∏—â–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
const connectedUsers = new Map(); // userId -> socket.id
const pendingCalls = new Map(); // callId -> callData
const callHistory = new Map(); // userId -> [callHistory]
const userFCMTokens = new Map(); // userId -> fcmToken

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
const CALL_WAIT_TIMEOUT = 60000; // 60 —Å–µ–∫—É–Ω–¥ –æ–∂–∏–¥–∞–Ω–∏—è
const MESSAGES_DIR = path.join(__dirname, "chats");
const CALL_HISTORY_FILE = path.join(__dirname, "call_history.json");
const FCM_TOKENS_FILE = path.join(__dirname, "fcm_tokens.json");

// –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
if (!fs.existsSync(MESSAGES_DIR)) {
   fs.mkdirSync(MESSAGES_DIR, { recursive: true });
   console.log("üìÅ Created chats directory");
}

// –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ –∑–≤–æ–Ω–∫–æ–≤
function loadCallHistory() {
   try {
      if (fs.existsSync(CALL_HISTORY_FILE)) {
         const data = fs.readFileSync(CALL_HISTORY_FILE, "utf8");
         const history = JSON.parse(data);
         for (const [userId, calls] of Object.entries(history)) {
            callHistory.set(
               userId,
               new Map(calls.map((call) => [call.callId, call])),
            );
         }
         console.log(`üìû Loaded call history for ${callHistory.size} users`);
      }
   } catch (error) {
      console.error("‚ùå Error loading call history:", error.message, error.stack);
   }
}

// –ó–∞–≥—Ä—É–∑–∫–∞ FCM —Ç–æ–∫–µ–Ω–æ–≤
function loadFCMTokens() {
   try {
      if (fs.existsSync(FCM_TOKENS_FILE)) {
         const data = fs.readFileSync(FCM_TOKENS_FILE, "utf8");
         const tokens = JSON.parse(data);
         for (const [userId, token] of Object.entries(tokens)) {
            userFCMTokens.set(userId, token);
         }
         console.log(`üì± Loaded FCM tokens for ${userFCMTokens.size} users`);
      }
   } catch (error) {
      console.error("‚ùå Error loading FCM tokens:", error.message, error.stack);
   }
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ FCM —Ç–æ–∫–µ–Ω–æ–≤
function saveFCMTokens() {
   try {
      const tokens = {};
      for (const [userId, token] of userFCMTokens.entries()) {
         tokens[userId] = token;
      }
      fs.writeFileSync(FCM_TOKENS_FILE, JSON.stringify(tokens, null, 2));
   } catch (error) {
      console.error("‚ùå Error saving FCM tokens:", error.message, error.stack);
   }
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –∑–≤–æ–Ω–∫–æ–≤
function saveCallHistory() {
   try {
      const history = {};
      for (const [userId, calls] of callHistory.entries()) {
         history[userId] = Array.from(calls.values());
      }
      fs.writeFileSync(CALL_HISTORY_FILE, JSON.stringify(history, null, 2));
   } catch (error) {
      console.error("‚ùå Error saving call history:", error.message, error.stack);
   }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–≤–æ–Ω–∫–µ
async function sendCallPushNotification(toUserId, callData) {
   try {
      const fcmToken = userFCMTokens.get(toUserId);

      if (!fcmToken) {
         console.log(`‚ùå No FCM token found for user ${toUserId}`);
         return false;
      }

      // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —á–µ—Ä–µ–∑ FCM
      // –î–ª—è –ø—Ä–∏–º–µ—Ä–∞, —Å–æ–∑–¥–∞–µ–º HTTP endpoint –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
      console.log(`üì± Sending push notification to ${toUserId} about call from ${callData.callerId}`);

      // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –∫–æ–¥ –¥–ª—è FCM:
      /*
      const admin = require('firebase-admin');
      const message = {
        token: fcmToken,
        notification: {
          title: '–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫',
          body: `–í–∞–º –∑–≤–æ–Ω–∏—Ç ${callData.contactName || callData.callerId}`,
        },
        data: {
          type: 'incoming_call',
          callId: callData.callId,
          fromUserId: callData.callerId,
          contactName: callData.contactName || callData.callerId,
          timestamp: new Date().toISOString()
        }
      };

      await admin.messaging().send(message);
      */

      // –í—Ä–µ–º–µ–Ω–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º HTTP endpoint –¥–ª—è —Å–∏–º—É–ª—è—Ü–∏–∏ push
      const pushData = {
        toUserId: toUserId,
        notification: {
          title: '–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫',
          body: `–í–∞–º –∑–≤–æ–Ω–∏—Ç ${callData.contactName || callData.callerId}`
        },
        data: {
          type: 'incoming_call',
          callId: callData.callId,
          fromUserId: callData.callerId,
          contactName: callData.contactName || callData.callerId,
          timestamp: new Date().toISOString()
        }
      };

      // –≠–º—É–ª–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É push (–≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ —ç—Ç–æ –±—É–¥–µ—Ç FCM)
      console.log(`üì≤ Push notification prepared for ${toUserId}:`, JSON.stringify(pushData));

      return true;
   } catch (error) {
      console.error("‚ùå Error sending push notification:", error.message, error.stack);
      return false;
   }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ñ–∞–π–ª
function saveMessageToFile(chat_id, messageData) {
   try {
      const filePath = path.join(MESSAGES_DIR, `${chat_id}.json`);

      let messages = [];

      // –ï—Å–ª–∏ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —á–∏—Ç–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
      if (fs.existsSync(filePath)) {
         const fileContent = fs.readFileSync(filePath, "utf8");
         try {
            messages = JSON.parse(fileContent);
            if (!Array.isArray(messages)) {
               messages = [];
            }
         } catch (parseError) {
            console.error(`‚ùå Error parsing ${filePath}:`, parseError.message);
            messages = [];
         }
      }

      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
      messages.push(messageData);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω–æ –≤ —Ñ–∞–π–ª
      fs.writeFileSync(filePath, JSON.stringify(messages, null, 2));

      console.log(
         `üíæ Message saved to ${chat_id}.json (total: ${messages.length} messages)`,
      );
      return true;
   } catch (error) {
      console.error(`‚ùå Error saving message to ${chat_id}.json:`, error.message, error.stack);
      return false;
   }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ —Ñ–∞–π–ª–∞
function loadMessagesFromFile(chat_id) {
   try {
      const filePath = path.join(MESSAGES_DIR, `${chat_id}.json`);

      if (!fs.existsSync(filePath)) {
         return [];
      }

      const fileContent = fs.readFileSync(filePath, "utf8");
      const messages = JSON.parse(fileContent);

      if (!Array.isArray(messages)) {
         console.warn(
            `‚ö†Ô∏è Invalid format in ${filePath}, returning empty array`,
         );
         return [];
      }

      console.log(`üìÇ Loaded ${messages.length} messages from ${chat_id}.json`);
      return messages;
   } catch (error) {
      console.error(`‚ùå Error loading messages from ${chat_id}.json:`, error.message, error.stack);
      return [];
   }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —á–∞—Ç–æ–≤
function getAllChats() {
   try {
      const files = fs.readdirSync(MESSAGES_DIR);
      return files
         .filter((file) => file.endsWith(".json"))
         .map((file) => file.replace(".json", ""));
   } catch (error) {
      console.error("‚ùå Error reading chats directory:", error.message, error.stack);
      return [];
   }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ ID –∑–≤–æ–Ω–∫–∞
function generateCallId() {
   return `call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
function isUserOnline(userId) {
   return connectedUsers.has(userId);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è socket –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
function getUserSocket(userId) {
   const socketId = connectedUsers.get(userId);
   return socketId ? io.sockets.sockets.get(socketId) : null;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–±—ã—Ç–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
function sendToUser(userId, event, data) {
   const socket = getUserSocket(userId);
   if (socket) {
      try {
         socket.emit(event, data);
         console.log(
            `üì§ Sent ${event} to ${userId}:`,
            JSON.stringify(data).substring(0, 200) + "...",
         );
         return true;
      } catch (error) {
         console.error(`‚ùå Error sending ${event} to ${userId}:`, error.message);
         return false;
      }
   }
   console.log(`‚ùå User ${userId} not found for event ${event}`);
   return false;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–≤–æ–Ω–∫–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é
function saveCallToHistory(callData) {
   try {
      const { callerId, toUserId, callId } = callData;

      if (!callerId || !toUserId || !callId) {
         console.error("‚ùå Invalid call data for history:", callData);
         return;
      }

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –∑–≤–æ–Ω—è—â–µ–≥–æ
      if (!callHistory.has(callerId)) {
         callHistory.set(callerId, new Map());
      }
      callHistory.get(callerId).set(callId, {
         ...callData,
         savedAt: new Date().toISOString(),
      });

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –ø–æ–ª—É—á–∞—Ç–µ–ª—è
      if (!callHistory.has(toUserId)) {
         callHistory.set(toUserId, new Map());
      }
      callHistory.get(toUserId).set(callId, {
         ...callData,
         savedAt: new Date().toISOString(),
      });

      saveCallHistory();
      console.log(
         `üíæ Call ${callId} saved to history for users ${callerId} and ${toUserId}`,
      );
   } catch (error) {
      console.error("‚ùå Error saving call to history:", error.message, error.stack);
   }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–≤–æ–Ω–∫–∞ - –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –° PUSH
function initiateCall(
   callerId,
   toUserId,
   providedCallId,
   isOfflineCall = false,
   contactName = null,
) {
   try {
      const callId = providedCallId || generateCallId();

      console.log(
         `üìû Call initiated from ${callerId} to ${toUserId}, callId: ${callId}${isOfflineCall ? " (OFFLINE CALL)" : ""}`,
      );

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–≤–æ–Ω—è—Ç –ª–∏ —Å–∞–º–æ–º—É —Å–µ–±–µ
      if (callerId === toUserId) {
         sendToUser(callerId, "call_failed", {
            callId: callId,
            error: "Cannot call yourself",
         });
         return null;
      }

      // –°–æ–∑–¥–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–≤–æ–Ω–∫–µ
      const callInfo = {
         callerId: callerId,
         toUserId: toUserId,
         callId: callId,
         createdAt: new Date().toISOString(),
         status: "initiated",
         isOfflineCall: isOfflineCall,
         contactName: contactName || toUserId,
      };

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–≤–æ–Ω–æ–∫ –≤ –ø–∞–º—è—Ç—å
      pendingCalls.set(callId, callInfo);

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–Ω–ª–∞–π–Ω –ª–∏ –ø–æ–ª—É—á–∞—Ç–µ–ª—å
      if (isUserOnline(toUserId)) {
         console.log(`‚úÖ User ${toUserId} is online, delivering call immediately`);
         deliverCall(callId);
      } else {
         console.log(`‚è≥ User ${toUserId} is offline`);

         // –û–¢–ü–†–ê–í–õ–Ø–ï–ú PUSH-–£–í–ï–î–û–ú–õ–ï–ù–ò–ï
         console.log(`üì± Sending push notification to offline user ${toUserId}`);
         sendCallPushNotification(toUserId, callInfo);

         // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –æ–∂–∏–¥–∞–Ω–∏—è
         callInfo.timeoutId = setTimeout(() => {
            handleCallTimeout(callId);
         }, CALL_WAIT_TIMEOUT);

         // –£–≤–µ–¥–æ–º–ª—è–µ–º –∑–≤–æ–Ω—è—â–µ–≥–æ –æ —Ç–æ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ñ—Ñ–ª–∞–π–Ω
         const waitingMessage = isOfflineCall
            ? `–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ${contactName || toUserId}...`
            : "User is offline, push notification sent";

         sendToUser(callerId, "call_waiting", {
            callId: callId,
            toUserId: toUserId,
            message: waitingMessage,
            pushSent: true // –°–æ–æ–±—â–∞–µ–º —á—Ç–æ push –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω
         });

         if (isOfflineCall) {
            console.log(
               `üìû Offline call ${callId} initiated - waiting for ${toUserId} to come online`,
            );
         }
      }

      return callId;
   } catch (error) {
      console.error("‚ùå Error initiating call:", error.message, error.stack);
      return null;
   }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –∑–≤–æ–Ω–∫–∞
function deliverCall(callId) {
   if (!pendingCalls.has(callId)) {
      console.log(`‚ùå Call ${callId} not found for delivery`);
      return false;
   }

   const callData = pendingCalls.get(callId);
   const { toUserId, callerId } = callData;

   // –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –µ—Å–ª–∏ –æ–Ω –±—ã–ª —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
   if (callData.timeoutId) {
      clearTimeout(callData.timeoutId);
   }

   // –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–≤–æ–Ω–æ–∫ –ø–æ–ª—É—á–∞—Ç–µ–ª—é
   const delivered = sendToUser(toUserId, "incoming_call", {
      fromUserId: callerId,
      callId: callId,
   });

   if (delivered) {
      console.log(`üì® Call ${callId} delivered to ${toUserId}`);
      callData.status = "delivered";
      callData.deliveredAt = new Date().toISOString();

      // –£–≤–µ–¥–æ–º–ª—è–µ–º –∑–≤–æ–Ω—è—â–µ–≥–æ –æ–± —É—Å–ø–µ—à–Ω–æ–π –¥–æ—Å—Ç–∞–≤–∫–µ
      sendToUser(callerId, "call_delivered", {
         toUserId: toUserId,
         callId: callId,
         status: "delivered",
      });

      return true;
   } else {
      console.log(`‚ùå Failed to deliver call ${callId} to ${toUserId}`);
      return false;
   }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–∞–π–º–∞—É—Ç–∞ –∑–≤–æ–Ω–∫–∞
function handleCallTimeout(callId) {
   if (pendingCalls.has(callId)) {
      const callData = pendingCalls.get(callId);

      console.log(`‚è∞ Call ${callId} expired after ${CALL_WAIT_TIMEOUT}ms`);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
      saveCallToHistory({
         ...callData,
         status: "missed",
         endedAt: new Date().toISOString(),
         reason: "timeout",
      });

      // –£–≤–µ–¥–æ–º–ª—è–µ–º –∑–≤–æ–Ω—è—â–µ–≥–æ –æ –Ω–µ—É–¥–∞—á–µ
      sendToUser(callData.callerId, "call_failed", {
         callId: callId,
         toUserId: callData.toUserId,
         error: "User unavailable",
         reason: "User did not come online within 60 seconds",
      });

      // –û—á–∏—â–∞–µ–º –∑–≤–æ–Ω–æ–∫ –∏–∑ –ø–∞–º—è—Ç–∏
      pendingCalls.delete(callId);
   }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è - –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
function handleUserConnection(userId) {
   console.log(`üîç Checking pending calls for newly connected user ${userId}`);

   // –ò—â–µ–º –≤—Å–µ –æ–∂–∏–¥–∞—é—â–∏–µ –∑–≤–æ–Ω–∫–∏ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
   const pendingCallIds = Array.from(pendingCalls.entries())
      .filter(
         ([callId, callData]) =>
            callData.toUserId === userId && callData.status === "initiated",
      )
      .map(([callId]) => callId);

   if (pendingCallIds.length === 0) {
      console.log(`üì≠ No pending calls for user ${userId}`);
      return;
   }

   console.log(
      `üì¨ Found ${pendingCallIds.length} pending calls for user ${userId}`,
   );

   // –î–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∂–¥—ã–π –æ–∂–∏–¥–∞—é—â–∏–π –∑–≤–æ–Ω–æ–∫
   pendingCallIds.forEach((callId) => {
      const callData = pendingCalls.get(callId);
      console.log(
         `üîÑ Attempting to deliver pending call ${callId} to ${userId}${callData.isOfflineCall ? " (OFFLINE CALL)" : ""}`,
      );

      // –ï—Å–ª–∏ —ç—Ç–æ –æ—Ñ—Ñ–ª–∞–π–Ω –∑–≤–æ–Ω–æ–∫, —É–≤–µ–¥–æ–º–ª—è–µ–º –∑–≤–æ–Ω—è—â–µ–≥–æ –æ —Ç–æ–º, —á—Ç–æ –ø–æ–ª—É—á–∞—Ç–µ–ª—å –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è
      if (callData.isOfflineCall) {
         sendToUser(callData.callerId, "call_delivered", {
            toUserId: userId,
            callId: callId,
            status: "user_online",
            message: `${callData.contactName || userId} –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É`,
         });
      }

      deliverCall(callId);
   });
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –∑–≤–æ–Ω–∫–∞
function cleanupCall(callId) {
   if (pendingCalls.has(callId)) {
      const callData = pendingCalls.get(callId);

      // –û—á–∏—â–∞–µ–º —Ç–∞–π–º–µ—Ä—ã
      if (callData.timeoutId) {
         clearTimeout(callData.timeoutId);
      }

      // –£–¥–∞–ª—è–µ–º –∏–∑ –ø–∞–º—è—Ç–∏
      pendingCalls.delete(callId);
      console.log(`üßπ Call ${callId} cleaned up from memory`);
   }
}

// –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –∑–≤–æ–Ω–∫–æ–≤ –∏ FCM —Ç–æ–∫–µ–Ω—ã –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
loadCallHistory();
loadFCMTokens();

// Middleware –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
app.use((req, res, next) => {
   console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
   next();
});

// API –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
app.get("/messages/:chat_id", (req, res) => {
   const { chat_id } = req.params;

   if (!chat_id) {
      return res.status(400).json({
         status: "Failed",
         error: "chat_id is required",
      });
   }

   const messages = loadMessagesFromFile(chat_id);

   res.json({
      status: "Success",
      chat_id: chat_id,
      messages: messages,
      total: messages.length,
   });
});

app.post("/messages/send", (req, res) => {
   const { chat_id, time_send, body, fromUserId, toUserId } = req.body;

   if (!chat_id || !time_send || !body) {
      return res.status(400).json({
         status: "Failed",
         error: "chat_id, time_send and body are required",
      });
   }

   const messageData = {
      chat_id: chat_id,
      time_send: time_send,
      body: body,
      fromUserId: fromUserId,
      toUserId: toUserId,
      timestamp: new Date().toISOString(),
      messageId: `${chat_id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
   };

   // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ñ–∞–π–ª
   const saveResult = saveMessageToFile(chat_id, messageData);

   if (!saveResult) {
      return res.status(500).json({
         status: "Failed",
         error: "Failed to save message",
      });
   }

   // –ï—Å–ª–∏ –ø–æ–ª—É—á–∞—Ç–µ–ª—å –æ–Ω–ª–∞–π–Ω, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
   if (toUserId && connectedUsers.has(toUserId)) {
      const targetSocketId = connectedUsers.get(toUserId);
      io.to(targetSocketId).emit("new_message", messageData);
   }

   // –¢–∞–∫–∂–µ —É–≤–µ–¥–æ–º–ª—è–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è –µ—Å–ª–∏ –æ–Ω –æ–Ω–ª–∞–π–Ω
   if (fromUserId && connectedUsers.has(fromUserId)) {
      const senderSocketId = connectedUsers.get(fromUserId);
      io.to(senderSocketId).emit("message_sent", {
         ...messageData,
         status: "sent",
      });
   }

   console.log(
      `üí¨ New message in chat ${chat_id}: ${body.substring(0, 50)}...`,
   );

   res.json({
      status: "Success",
      message: messageData,
   });
});

// –ù–û–í–´–ô API: –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è FCM —Ç–æ–∫–µ–Ω–∞
app.post("/register-fcm-token", (req, res) => {
   const { userId, fcmToken } = req.body;

   if (!userId || !fcmToken) {
      return res.status(400).json({
         status: "Failed",
         error: "userId and fcmToken are required",
      });
   }

   userFCMTokens.set(userId, fcmToken);
   saveFCMTokens();

   console.log(`‚úÖ FCM token registered for user ${userId}`);

   res.json({
      status: "Success",
      message: "FCM token registered successfully",
   });
});

// API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ –∑–≤–æ–Ω–∫–æ–≤
app.get("/call-history/:userId", (req, res) => {
   const { userId } = req.params;

   if (!userId) {
      return res.status(400).json({
         status: "Failed",
         error: "userId is required",
      });
   }

   const userCalls = callHistory.has(userId)
      ? Array.from(callHistory.get(userId).values())
      : [];

   res.json({
      status: "Success",
      userId: userId,
      calls: userCalls.sort(
         (a, b) => new Date(b.createdAt) - new Date(a.createdAt),
      ),
      total: userCalls.length,
   });
});

// –ù–û–í–´–ô API: –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—Ñ—Ñ–ª–∞–π–Ω –∑–≤–æ–Ω–∫–∞—Ö
app.get("/offline-calls/:userId", (req, res) => {
   const { userId } = req.params;

   if (!userId) {
      return res.status(400).json({
         status: "Failed",
         error: "userId is required",
      });
   }

   // –ò—â–µ–º –æ—Ñ—Ñ–ª–∞–π–Ω –∑–≤–æ–Ω–∫–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
   const offlineCalls = Array.from(pendingCalls.entries())
      .filter(
         ([callId, callData]) =>
            (callData.callerId === userId || callData.toUserId === userId) &&
            callData.isOfflineCall === true,
      )
      .map(([callId, callData]) => ({
         callId: callId,
         callerId: callData.callerId,
         toUserId: callData.toUserId,
         contactName: callData.contactName,
         status: callData.status,
         createdAt: callData.createdAt,
         isOfflineCall: callData.isOfflineCall,
      }));

   res.json({
      status: "Success",
      userId: userId,
      offlineCalls: offlineCalls,
      total: offlineCalls.length,
   });
});

// API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —á–∞—Ç–æ–≤
app.get("/chats", (req, res) => {
   const chats = getAllChats();

   // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∞—Ç–∞ –ø–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π
   const chatList = chats.map((chat_id) => {
      const messages = loadMessagesFromFile(chat_id);
      const lastMessage =
         messages.length > 0 ? messages[messages.length - 1] : null;

      return {
         chat_id: chat_id,
         message_count: messages.length,
         last_message: lastMessage
            ? {
                 body: lastMessage.body,
                 time_send: lastMessage.time_send,
                 fromUserId: lastMessage.fromUserId,
              }
            : null,
         created_at: messages.length > 0 ? messages[0].time_send : null,
      };
   });

   res.json({
      status: "Success",
      chats: chatList,
      total: chatList.length,
   });
});

// –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ - –æ—Ç–¥–∞–µ–º HTML —Ñ–∞–π–ª
app.get("/", (req, res) => {
   res.sendFile(path.join(__dirname, "index.html"));
});

// HTTP endpoint –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
app.post("/connect", (req, res) => {
   const { userId } = req.body;

   if (!userId) {
      console.log(`‚ùå Failed connection attempt - missing userId`);
      return res
         .status(400)
         .json({ status: "Failed", error: "User ID is required" });
   }

   console.log(`‚úÖ User ${userId} connected via HTTP`);
   res.json({ status: "Success", message: "User registered successfully" });
});

app.get("/status", (req, res) => {
   const users = Array.from(connectedUsers.keys());
   const chats = getAllChats();
   const totalMessages = chats.reduce((acc, chat_id) => {
      const messages = loadMessagesFromFile(chat_id);
      return acc + messages.length;
   }, 0);

   // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∑–≤–æ–Ω–∫–∞–º
   const allCalls = Array.from(pendingCalls.values());
   const callStats = {
      pending: allCalls.filter((call) => call.status === "initiated").length,
      delivered: allCalls.filter((call) => call.status === "delivered").length,
      offlineCalls: allCalls.filter((call) => call.isOfflineCall === true)
         .length,
      totalHistory: Array.from(callHistory.values()).reduce(
         (acc, userCalls) => acc + userCalls.size,
         0,
      ),
   };

   // –î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –æ—Ñ—Ñ–ª–∞–π–Ω –∑–≤–æ–Ω–∫–∞–º
   const offlineCallStats = {
      waiting: allCalls.filter(
         (call) => call.isOfflineCall && call.status === "initiated",
      ).length,
      delivered: allCalls.filter(
         (call) => call.isOfflineCall && call.status === "delivered",
      ).length,
   };

   res.json({
      connectedUsers: users,
      totalConnected: users.length,
      callStats: callStats,
      offlineCallStats: offlineCallStats,
      chatStats: {
         totalChats: chats.length,
         totalMessages: totalMessages,
      },
      fcmStats: {
         registeredTokens: userFCMTokens.size
      },
      serverTime: new Date().toISOString(),
      uptime: process.uptime(),
   });
});

// –ù–û–í–´–ô API: –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ö–æ–¥—è—â–∏—Ö –∑–≤–æ–Ω–∫–æ–≤ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ HTTP
app.get("/incoming-calls/:userId", (req, res) => {
   const { userId } = req.params;

   if (!userId) {
      return res.status(400).json({
         status: "Failed",
         error: "userId is required",
      });
   }

   try {
      // –ò—â–µ–º –≤—Å–µ –æ–∂–∏–¥–∞—é—â–∏–µ –∑–≤–æ–Ω–∫–∏ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const incomingCalls = Array.from(pendingCalls.entries())
         .filter(
            ([callId, callData]) =>
               callData.toUserId === userId && 
               (callData.status === "initiated" || callData.status === "delivered")
         )
         .map(([callId, callData]) => ({
            callId: callId,
            callerId: callData.callerId,
            contactName: callData.contactName,
            status: callData.status,
            createdAt: callData.createdAt,
            isOfflineCall: callData.isOfflineCall,
            // –î–æ–±–∞–≤–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –º–µ—Ç–∫—É –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
            lastChecked: new Date().toISOString()
         }));

      console.log(`üìû HTTP: Found ${incomingCalls.length} incoming calls for ${userId}`);

      res.json({
         status: "Success",
         userId: userId,
         incomingCalls: incomingCalls,
         total: incomingCalls.length,
         timestamp: new Date().toISOString(),
      });
   } catch (error) {
      console.error("‚ùå Error getting incoming calls:", error.message);
      res.status(500).json({
         status: "Failed",
         error: error.message,
      });
   }
});

// –ù–û–í–´–ô API: –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–≤–æ–Ω–∫–∞ —á–µ—Ä–µ–∑ HTTP
app.post("/call-end", (req, res) => {
   const { callId, userId } = req.body;

   if (!userId) {
      return res.status(400).json({
         status: "Failed",
         error: "userId is required",
      });
   }

   console.log(`üìû HTTP call_end request from user ${userId} for callId: ${callId}`);

   try {
      let callData = null;
      let foundCallId = null;
      let isFromPending = false;

      // –ü–æ–∏—Å–∫ –∑–≤–æ–Ω–∫–∞ –ø–æ callId –∏–ª–∏ –ø–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º
      if (callId) {
         // –ò—â–µ–º –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É callId
         for (const [storedCallId, data] of pendingCalls.entries()) {
            if (storedCallId.startsWith(callId)) {
               callData = data;
               foundCallId = storedCallId;
               isFromPending = true;
               break;
            }
         }
      } else {
         // –ò—â–µ–º –ø–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º –∑–≤–æ–Ω–∫–∞ (—Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–≤–æ–Ω–∫–∏)
         for (const [storedCallId, data] of pendingCalls.entries()) {
            if ((data.callerId === userId || data.toUserId === userId) && 
                data.status !== "ended" && data.status !== "rejected" && data.status !== "missed") {
               callData = data;
               foundCallId = storedCallId;
               isFromPending = true;
               break;
            }
         }
      }

      if (!callData) {
         // –ò—â–µ–º –≤ –∏—Å—Ç–æ—Ä–∏–∏ –∑–≤–æ–Ω–∫–æ–≤
         for (const [uid, userCalls] of callHistory.entries()) {
            for (const [storedCallId, data] of userCalls.entries()) {
               if (callId && storedCallId.startsWith(callId)) {
                  callData = data;
                  foundCallId = storedCallId;
                  break;
               } else if (!callId && 
                         (data.callerId === userId || data.toUserId === userId) && 
                         data.status !== "ended" && data.status !== "rejected" && data.status !== "missed") {
                  callData = data;
                  foundCallId = storedCallId;
                  break;
               }
            }
            if (callData) break;
         }
      }

      if (!callData) {
         console.log(`‚ùå Call not found for user ${userId}`);
         return res.status(404).json({
            status: "Failed",
            error: "Call not found or already ended",
         });
      }

      const { callerId, toUserId } = callData;

      console.log(`üìû Ending call ${foundCallId} between ${callerId} and ${toUserId}`);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
      if (callData.status !== "ended" && callData.status !== "rejected" && callData.status !== "missed") {
         saveCallToHistory({
            ...callData,
            status: "ended",
            endedAt: new Date().toISOString(),
            reason: "ended_by_http",
         });
      }

      // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Ç–æ—Ä–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ —á–µ—Ä–µ–∑ Socket.IO
      const otherUserId = userId === callerId ? toUserId : callerId;
      const sent = sendToUser(otherUserId, "call_ended", {
         fromUserId: userId,
         callId: foundCallId,
      });

      if (sent) {
         console.log(`‚úÖ Successfully sent call_ended to ${otherUserId}`);
      } else {
         console.log(`‚ö†Ô∏è Failed to send call_ended to ${otherUserId} - user may be offline`);
      }

      // –û—á–∏—â–∞–µ–º –∏–∑ pendingCalls
      if (isFromPending) {
         cleanupCall(foundCallId);
      }

      res.json({
         status: "Success",
         message: "Call ended successfully",
         callId: foundCallId,
      });
   } catch (error) {
      console.error("‚ùå Error ending call:", error.message);
      res.status(500).json({
         status: "Failed",
         error: error.message,
      });
   }
});

// –ù–û–í–´–ô API: –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –∑–≤–æ–Ω–∫–∞ —á–µ—Ä–µ–∑ HTTP
app.get("/call-status/:callId", (req, res) => {
   const { callId } = req.params;
   const { userId } = req.query;

   if (!callId) {
      return res.status(400).json({
         status: "Failed",
         error: "callId is required",
      });
   }

   try {
      console.log(`üîç Checking call status for: ${callId}`);

      // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—â–µ–º –∑–≤–æ–Ω–æ–∫ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É (callId –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å timestamp)
      let callData = null;
      let foundCallId = null;

      // –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –≤ pendingCalls –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É
      for (const [storedCallId, data] of pendingCalls.entries()) {
         if (storedCallId.startsWith(callId)) {
            callData = data;
            foundCallId = storedCallId;
            console.log(`üìû Found call ${storedCallId} in pending calls with status: ${callData.status}`);
            break;
         }
      }

      if (!callData) {
         console.log(`üìû Call ${callId} not found in pending calls, searching history...`);

         // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—â–µ–º –≤ –∏—Å—Ç–æ—Ä–∏–∏ –∑–≤–æ–Ω–∫–æ–≤ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É
         for (const [userId, userCalls] of callHistory.entries()) {
            for (const [storedCallId, data] of userCalls.entries()) {
               if (storedCallId.startsWith(callId)) {
                  callData = data;
                  foundCallId = storedCallId;
                  console.log(`üìû Found call ${storedCallId} in history for user ${userId}`);
                  break;
               }
            }
            if (callData) break;
         }

         if (callData) {
            console.log(`üìû Found call ${foundCallId} in history with status: ${callData.status}`);
            return res.json({
               status: "Success",
               callId: foundCallId,
               currentStatus: callData.status,
               endedAt: callData.endedAt,
               isActive: false,
            });
         }

         // ‚úÖ –ù–û–í–û–ï: –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ callId, –∏—â–µ–º –ø–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º –∑–≤–æ–Ω–∫–∞
         if (userId) {
            console.log(`üîç Call ${callId} not found by ID, searching by participants...`);
            console.log(`üîç Searching for call with participant: ${userId}`);

            // –ò—â–µ–º –≤ pendingCalls –ø–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º (—Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–≤–æ–Ω–∫–∏)
            for (const [storedCallId, data] of pendingCalls.entries()) {
               if ((data.callerId === userId || data.toUserId === userId) && 
                   data.status !== "ended" && data.status !== "rejected" && data.status !== "missed") {
                  callData = data;
                  foundCallId = storedCallId;
                  console.log(`üìû Found active call ${storedCallId} in pending calls by participants: ${data.callerId} <-> ${data.toUserId}`);
                  break;
               }
            }

            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ pendingCalls, –∏—â–µ–º –≤ –∏—Å—Ç–æ—Ä–∏–∏ (—Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–≤–æ–Ω–∫–∏)
            if (!callData) {
               for (const [userId, userCalls] of callHistory.entries()) {
                  for (const [storedCallId, data] of userCalls.entries()) {
                     if ((data.callerId === userId || data.toUserId === userId) && 
                         data.status !== "ended" && data.status !== "rejected" && data.status !== "missed") {
                        callData = data;
                        foundCallId = storedCallId;
                        console.log(`üìû Found active call ${storedCallId} in history by participants: ${data.callerId} <-> ${data.toUserId}`);
                        break;
                     }
                  }
                  if (callData) break;
               }
            }
         }

         if (!callData) {
            console.log(`‚ùå Call ${callId} not found in pending calls or history`);
            return res.status(404).json({
               status: "Failed",
               error: "Call not found",
            });
         }
      }

      res.json({
         status: "Success",
         callId: foundCallId,
         currentStatus: callData.status,
         isActive: true,
      });
   } catch (error) {
      console.error("‚ùå Error getting call status:", error.message);
      res.status(500).json({
         status: "Failed",
         error: error.message,
      });
   }
});

// Socket.IO —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
io.on("connection", (socket) => {
   console.log(`üîå New socket connection: ${socket.id}`);

   // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
   socket.on("register", (userId) => {
      if (!userId) {
         socket.emit("registration_failed", {
            error: "User ID is required",
         });
         return;
      }

      // –£–î–ê–õ–Ø–ï–ú –ü–†–û–í–ï–†–ö–£ –ù–ê –î–£–ë–õ–ò–ö–ê–¢ - —Ä–∞–∑—Ä–µ—à–∞–µ–º –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
      // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é –∑–∞–ø–∏—Å—å –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è
      if (connectedUsers.has(userId)) {
         console.log(`üîÑ User ${userId} reconnected, updating socket ID`);
         const oldSocketId = connectedUsers.get(userId);
         const oldSocket = io.sockets.sockets.get(oldSocketId);
         if (oldSocket && oldSocket !== socket) {
            oldSocket.disconnect(true); // –û—Ç–∫–ª—é—á–∞–µ–º —Å—Ç–∞—Ä—ã–π —Å–æ–∫–µ—Ç
         }
      }

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–≤—è–∑—å –º–µ–∂–¥—É socket.id –∏ userId
      connectedUsers.set(userId, socket.id);
      socket.userId = userId;

      console.log(`‚úÖ User ${userId} registered with socket ${socket.id}`);

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –¥–æ—Å—Ç–∞–≤–ª—è–µ–º –æ–∂–∏–¥–∞—é—â–∏–µ –∑–≤–æ–Ω–∫–∏ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      handleUserConnection(userId);

      socket.emit("registration_success", {
         status: "Success",
         userId: userId,
         connectedUsers: Array.from(connectedUsers.keys()).filter(
            (id) => id !== userId,
         ),
      });

      // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –æ –Ω–æ–≤–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
      socket.broadcast.emit("user_connected", { userId });

      console.log(`üìä Total connected users: ${connectedUsers.size}`);
   });

   // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è FCM —Ç–æ–∫–µ–Ω–∞ —á–µ—Ä–µ–∑ WebSocket
   socket.on("register_fcm_token", (data) => {
      const { fcmToken } = data;
      const userId = socket.userId;

      if (!userId || !fcmToken) {
         socket.emit("fcm_token_failed", {
            error: "User ID and FCM token are required",
         });
         return;
      }

      userFCMTokens.set(userId, fcmToken);
      saveFCMTokens();

      console.log(`‚úÖ FCM token registered for user ${userId}`);
      socket.emit("fcm_token_success", {
         status: "Success",
         message: "FCM token registered successfully",
      });
   });

   // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ WebSocket
   socket.on("send_message", (data) => {
      const { chat_id, time_send, body, toUserId } = data;
      const fromUserId = socket.userId;

      if (!chat_id || !time_send || !body) {
         socket.emit("message_failed", {
            error: "chat_id, time_send and body are required",
         });
         return;
      }

      const messageData = {
         chat_id: chat_id,
         time_send: time_send,
         body: body,
         fromUserId: fromUserId,
         toUserId: toUserId,
         timestamp: new Date().toISOString(),
         messageId: `${chat_id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      };

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ñ–∞–π–ª
      const saveResult = saveMessageToFile(chat_id, messageData);

      if (!saveResult) {
         socket.emit("message_failed", {
            error: "Failed to save message",
         });
         return;
      }

      // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é
      socket.emit("message_sent", {
         ...messageData,
         status: "sent",
      });

      // –ï—Å–ª–∏ –ø–æ–ª—É—á–∞—Ç–µ–ª—å –æ–Ω–ª–∞–π–Ω, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
      if (toUserId && connectedUsers.has(toUserId)) {
         const targetSocketId = connectedUsers.get(toUserId);
         io.to(targetSocketId).emit("new_message", messageData);
      }

      console.log(
         `üí¨ New message in chat ${chat_id} from ${fromUserId}: ${body.substring(0, 50)}...`,
      );
   });

   // –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞
   socket.on("load_chat_history", (data) => {
      const { chat_id } = data;

      if (!chat_id) {
         socket.emit("chat_history_error", {
            error: "chat_id is required",
         });
         return;
      }

      const messages = loadMessagesFromFile(chat_id);

      socket.emit("chat_history_loaded", {
         chat_id: chat_id,
         messages: messages,
         total: messages.length,
      });

      console.log(
         `üìÇ Sent ${messages.length} messages from ${chat_id} to user ${socket.userId}`,
      );
   });

   // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–≤–æ–Ω–∫–∞ —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π fromUserId
   socket.on("initiate_call", (data) => {
      const { toUserId, callId: clientCallId, isOfflineCall, contactName, fromUserId: providedFromUserId } = data;

      // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º providedFromUserId –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å, –∏–Ω–∞—á–µ socket.userId
      const fromUserId = providedFromUserId || socket.userId;

      if (!fromUserId || !toUserId) {
         socket.emit("call_failed", {
            error: "fromUserId and toUserId are required",
         });
         return;
      }

      // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ providedFromUserId —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å socket.userId (–µ—Å–ª–∏ –æ–Ω –±—ã–ª –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω)
      if (providedFromUserId && providedFromUserId !== socket.userId) {
         socket.emit("call_failed", {
            error: "Authentication failed: userId mismatch",
         });
         return;
      }

      console.log(
         `üìû Initiating call from ${fromUserId} to ${toUserId}${isOfflineCall ? " (OFFLINE CALL)" : ""}`,
      );

      const callId = initiateCall(
         fromUserId,
         toUserId,
         clientCallId,
         isOfflineCall,
         contactName,
      );

      if (!callId) {
         // –û—à–∏–±–∫–∞ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞ –≤ initiateCall
         return;
      }

      // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –æ—Ñ—Ñ–ª–∞–π–Ω –∑–≤–æ–Ω–∫–æ–≤ —É–∂–µ –≤–∫–ª—é—á–µ–Ω–∞ –≤ initiateCall
      if (isOfflineCall) {
         console.log(
            `üìû Offline call ${callId} initiated - waiting for ${toUserId} to come online`,
         );
      }

      console.log(`üìû Call ${callId} initiated successfully`);
   });

   // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–∏–Ω—è—Ç–∏—è –∑–≤–æ–Ω–∫–∞
   socket.on("accept_call", (data) => {
      const { callId } = data;
      const toUserId = socket.userId;

      if (!pendingCalls.has(callId)) {
         socket.emit("call_failed", {
            error: "Call not found",
         });
         return;
      }

      const callData = pendingCalls.get(callId);
      const { callerId } = callData;

      console.log(
         `‚úÖ Call accepted by ${toUserId} from ${callerId}, callId: ${callId}`,
      );

      // –£–≤–µ–¥–æ–º–ª—è–µ–º –∑–≤–æ–Ω—è—â–µ–≥–æ –æ –ø—Ä–∏–Ω—è—Ç–∏–∏
      sendToUser(callerId, "call_accepted", {
         toUserId: toUserId,
         callId: callId,
      });

      // –û—á–∏—â–∞–µ–º –∑–≤–æ–Ω–æ–∫ –∏–∑ —Å–∏—Å—Ç–µ–º –æ–∂–∏–¥–∞–Ω–∏—è
      cleanupCall(callId);
   });

   // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –∑–≤–æ–Ω–∫–∞
   socket.on("reject_call", (data) => {
      const { callId } = data;
      const toUserId = socket.userId;

      let callData = null;
      let isFromPending = false;

      // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—â–µ–º –∑–≤–æ–Ω–æ–∫ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É (callId –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å timestamp)
      let foundCallId = null;

      // –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –≤ pendingCalls –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É
      for (const [storedCallId, data] of pendingCalls.entries()) {
         if (storedCallId.startsWith(callId)) {
            callData = data;
            foundCallId = storedCallId;
            isFromPending = true;
            console.log(`üìû Found call ${storedCallId} in pending calls for rejection`);
            break;
         }
      }

      if (!callData) {
         // ‚úÖ –ù–û–í–û–ï: –ò—â–µ–º –≤ –∏—Å—Ç–æ—Ä–∏–∏ –∑–≤–æ–Ω–∫–æ–≤ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É
         console.log(`üîç Call ${callId} not in pending, searching in history...`);

         for (const [userId, userCalls] of callHistory.entries()) {
            for (const [storedCallId, data] of userCalls.entries()) {
               if (storedCallId.startsWith(callId)) {
                  callData = data;
                  foundCallId = storedCallId;
                  console.log(`üìû Found call ${storedCallId} in history for user ${userId}`);
                  break;
               }
            }
            if (callData) break;
         }
      }

      // ‚úÖ –ù–û–í–û–ï: –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ callId, –∏—â–µ–º –ø–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º –∑–≤–æ–Ω–∫–∞
      if (!callData) {
         console.log(`üîç Call ${callId} not found by ID, searching by participants...`);
         console.log(`üîç Searching for call between ${toUserId} and other participants`);

         // –ò—â–µ–º –≤ pendingCalls –ø–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º (—Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–≤–æ–Ω–∫–∏)
         for (const [storedCallId, data] of pendingCalls.entries()) {
            if ((data.callerId === toUserId || data.toUserId === toUserId) && 
                data.status !== "ended" && data.status !== "rejected" && data.status !== "missed") {
               callData = data;
               foundCallId = storedCallId;
               isFromPending = true;
               console.log(`üìû Found active call ${storedCallId} in pending calls by participants: ${data.callerId} <-> ${data.toUserId}`);
               break;
            }
         }

         // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ pendingCalls, –∏—â–µ–º –≤ –∏—Å—Ç–æ—Ä–∏–∏ (—Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–≤–æ–Ω–∫–∏)
         if (!callData) {
            for (const [userId, userCalls] of callHistory.entries()) {
               for (const [storedCallId, data] of userCalls.entries()) {
                  if ((data.callerId === toUserId || data.toUserId === toUserId) && 
                      data.status !== "ended" && data.status !== "rejected" && data.status !== "missed") {
                     callData = data;
                     foundCallId = storedCallId;
                     console.log(`üìû Found active call ${storedCallId} in history by participants: ${data.callerId} <-> ${data.toUserId}`);
                     break;
                  }
               }
               if (callData) break;
            }
         }
      }

      if (!callData) {
         console.log(`‚ùå Call ${callId} not found in pending calls or history for rejection`);
         socket.emit("call_failed", {
            error: "Call not found",
         });
         return;
      }

      const { callerId } = callData;

      console.log(
         `‚ùå Call rejected by ${toUserId} from ${callerId}, callId: ${foundCallId}`,
      );

      // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∑–≤–æ–Ω–æ–∫ –µ—â–µ –Ω–µ –±—ã–ª –æ—Ç–∫–ª–æ–Ω–µ–Ω
      if (callData.status !== "rejected" && callData.status !== "ended" && callData.status !== "missed") {
         saveCallToHistory({
            ...callData,
            status: "rejected",
            endedAt: new Date().toISOString(),
            reason: "rejected_by_user",
         });
         console.log(`üíæ Call ${foundCallId} status updated to 'rejected' in history`);
      } else {
         console.log(`üìû Call ${foundCallId} was already ${callData.status}, skipping history update`);
      }

      // –£–≤–µ–¥–æ–º–ª—è–µ–º –∑–≤–æ–Ω—è—â–µ–≥–æ –æ–± –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏
      console.log(`üì§ Attempting to send call_rejected to callerId: ${callerId}`);
      const sent = sendToUser(callerId, "call_rejected", {
         fromUserId: toUserId,
         callId: foundCallId,
      });

      // ‚úÖ –ù–û–í–û–ï: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å ID –∏ —Å—Ç–∞—Ç—É—Å–æ–º
      console.log(`üì§ Attempting to send call_status_update to callerId: ${callerId}`);
      const statusSent = sendToUser(callerId, "call_status_update", {
         callId: foundCallId,
         status: "–ø—Ä–µ–∫—Ä–∞—â–µ–Ω",
         fromUserId: toUserId,
         reason: "rejected_by_user",
         timestamp: new Date().toISOString()
      });

      if (sent) {
         console.log(`‚úÖ Successfully sent call_rejected to ${callerId}`);
      } else {
         console.log(`‚ö†Ô∏è Failed to send call_rejected to ${callerId} - user may be offline, call will be tracked via HTTP polling`);
      }

      if (statusSent) {
         console.log(`‚úÖ Successfully sent call_status_update to ${callerId}`);
      } else {
         console.log(`‚ö†Ô∏è Failed to send call_status_update to ${callerId}`);
      }

      // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û—á–∏—â–∞–µ–º –∑–≤–æ–Ω–æ–∫ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –±—ã–ª –≤ pendingCalls
      if (isFromPending) {
         cleanupCall(foundCallId);
      } else {
         console.log(`üìû Call ${foundCallId} was already processed, skipping cleanup`);
      }
   });

   // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–≤–æ–Ω–∫–∞
   socket.on("end_call", (data) => {
      const { callId } = data;
      const fromUserId = socket.userId;

      let callData = null;
      let isFromPending = false;

      // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—â–µ–º –∑–≤–æ–Ω–æ–∫ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É (callId –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å timestamp)
      let foundCallId = null;

      // –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –≤ pendingCalls –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É
      for (const [storedCallId, data] of pendingCalls.entries()) {
         if (storedCallId.startsWith(callId)) {
            callData = data;
            foundCallId = storedCallId;
            isFromPending = true;
            console.log(`üìû Found call ${storedCallId} in pending calls`);
            break;
         }
      }

      if (!callData) {
         // ‚úÖ –ù–û–í–û–ï: –ò—â–µ–º –≤ –∏—Å—Ç–æ—Ä–∏–∏ –∑–≤–æ–Ω–∫–æ–≤ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É
         console.log(`üîç Call ${callId} not in pending, searching in history...`);

         for (const [userId, userCalls] of callHistory.entries()) {
            for (const [storedCallId, data] of userCalls.entries()) {
               if (storedCallId.startsWith(callId)) {
                  callData = data;
                  foundCallId = storedCallId;
                  console.log(`üìû Found call ${storedCallId} in history for user ${userId}`);
                  break;
               }
            }
            if (callData) break;
         }
      }

      // ‚úÖ –ù–û–í–û–ï: –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ callId, –∏—â–µ–º –ø–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º –∑–≤–æ–Ω–∫–∞
      if (!callData) {
         console.log(`üîç Call ${callId} not found by ID, searching by participants...`);
         console.log(`üîç Searching for call between ${fromUserId} and other participants`);

         // –ò—â–µ–º –≤ pendingCalls –ø–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º (—Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–≤–æ–Ω–∫–∏)
         for (const [storedCallId, data] of pendingCalls.entries()) {
            if ((data.callerId === fromUserId || data.toUserId === fromUserId) && 
                data.status !== "ended" && data.status !== "rejected" && data.status !== "missed") {
               callData = data;
               foundCallId = storedCallId;
               isFromPending = true;
               console.log(`üìû Found active call ${storedCallId} in pending calls by participants: ${data.callerId} <-> ${data.toUserId}`);
               break;
            }
         }

         // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ pendingCalls, –∏—â–µ–º –≤ –∏—Å—Ç–æ—Ä–∏–∏ (—Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–≤–æ–Ω–∫–∏)
         if (!callData) {
            for (const [userId, userCalls] of callHistory.entries()) {
               for (const [storedCallId, data] of userCalls.entries()) {
                  if ((data.callerId === fromUserId || data.toUserId === fromUserId) && 
                      data.status !== "ended" && data.status !== "rejected" && data.status !== "missed") {
                     callData = data;
                     foundCallId = storedCallId;
                     console.log(`üìû Found active call ${storedCallId} in history by participants: ${data.callerId} <-> ${data.toUserId}`);
                     break;
                  }
               }
               if (callData) break;
            }
         }
      }

      if (!callData) {
         console.log(`‚ùå Call ${callId} not found in pending calls or history`);
         return;
      }

      const { callerId, toUserId } = callData;

      console.log(
         `üìû Call ended between ${callerId} and ${toUserId}, callId: ${foundCallId}`,
      );

      // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∑–≤–æ–Ω–æ–∫ –µ—â–µ –Ω–µ –±—ã–ª –∑–∞–≤–µ—Ä—à–µ–Ω
      if (callData.status !== "ended" && callData.status !== "rejected" && callData.status !== "missed") {
         saveCallToHistory({
            ...callData,
            status: "ended",
            endedAt: new Date().toISOString(),
            reason: "ended_by_user",
         });
         console.log(`üíæ Call ${callId} status updated to 'ended' in history`);
      } else {
         console.log(`üìû Call ${callId} was already ${callData.status}, skipping history update`);
      }

      // –£–≤–µ–¥–æ–º–ª—è–µ–º –¥—Ä—É–≥—É—é —Å—Ç–æ—Ä–æ–Ω—É
      const otherUserId = fromUserId === callerId ? toUserId : callerId;
      console.log(`üì§ Attempting to send call_ended to otherUserId: ${otherUserId}`);
      const sent = sendToUser(otherUserId, "call_ended", {
         fromUserId: fromUserId,
         callId: foundCallId,
      });

      // ‚úÖ –ù–û–í–û–ï: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å ID –∏ —Å—Ç–∞—Ç—É—Å–æ–º
      console.log(`üì§ Attempting to send call_status_update to otherUserId: ${otherUserId}`);
      const statusSent = sendToUser(otherUserId, "call_status_update", {
         callId: foundCallId,
         status: "–ø—Ä–µ–∫—Ä–∞—â–µ–Ω",
         fromUserId: fromUserId,
         reason: "ended_by_user",
         timestamp: new Date().toISOString()
      });

      if (sent) {
         console.log(`‚úÖ Successfully sent call_ended to ${otherUserId}`);
      } else {
         console.log(`‚ö†Ô∏è Failed to send call_ended to ${otherUserId} - user may be offline, call will be tracked via HTTP polling`);
      }

      if (statusSent) {
         console.log(`‚úÖ Successfully sent call_status_update to ${otherUserId}`);
      } else {
         console.log(`‚ö†Ô∏è Failed to send call_status_update to ${otherUserId}`);
      }

      // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û—á–∏—â–∞–µ–º –∑–≤–æ–Ω–æ–∫ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –±—ã–ª –≤ pendingCalls
      if (isFromPending) {
         cleanupCall(foundCallId);
      } else {
         console.log(`üìû Call ${foundCallId} was already processed, skipping cleanup`);
      }
   });

   // WebRTC signaling - —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
   socket.on("webrtc_signal", (data) => {
      const { type, toUserId, sdp, candidate, callId } = data;
      const fromUserId = socket.userId;

      console.log(
         `üì® WebRTC signal: ${type} from ${fromUserId} to ${toUserId}, callId: ${callId}`,
      );

      if (!type || !toUserId) {
         console.log(`‚ùå Invalid webrtc_signal: missing type or toUserId`);
         return;
      }

      const signalData = {
         type: type,
         fromUserId: fromUserId,
         callId: callId,
      };

      // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
      if (sdp) {
         signalData.sdp = sdp;
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
      if (candidate && type === "ice_candidate") {
         console.log(
            "üîç DEBUG: Processing ICE candidate:",
            JSON.stringify(candidate).substring(0, 200),
         );

         if (
            candidate.candidate &&
            candidate.sdpMid !== undefined &&
            candidate.sdpMLineIndex !== undefined
         ) {
            signalData.candidate = candidate;
         } else if (candidate.sdp) {
            signalData.candidate = {
               sdpMid: candidate.sdpMid || "0",
               sdpMLineIndex: candidate.sdpMLineIndex || 0,
               candidate: candidate.sdp,
            };
         } else {
            signalData.candidate = {
               sdpMid: "0",
               sdpMLineIndex: 0,
               candidate: candidate.candidate || JSON.stringify(candidate),
            };
         }

         console.log(
            "‚úÖ DEBUG: Final ICE candidate structure:",
            JSON.stringify(signalData.candidate),
         );
      }

      const delivered = sendToUser(toUserId, "webrtc_signal", signalData);

      if (delivered) {
         console.log(`‚úÖ WebRTC signal ${type} delivered to ${toUserId}`);
      } else {
         console.log(`‚ùå Failed to deliver WebRTC signal to ${toUserId}`);
      }
   });

   // WebRTC ICE candidates (—Å—Ç–∞—Ä—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
   socket.on("webrtc_ice_candidate", (data) => {
      const { toUserId, candidate, callId } = data;

      console.log(
         `üîç DEBUG: webrtc_ice_candidate from ${socket.userId} to ${toUserId}, callId: ${callId}`,
      );

      const iceCandidateData = {
         fromUserId: socket.userId,
         callId: callId,
      };

      if (candidate) {
         console.log(
            "üîç DEBUG: Old ICE candidate structure:",
            JSON.stringify(candidate).substring(0, 200),
         );

         if (typeof candidate === "string") {
            iceCandidateData.candidate = {
               sdpMid: "0",
               sdpMLineIndex: 0,
               candidate: candidate,
            };
         } else if (candidate.candidate && candidate.sdpMid !== undefined) {
            iceCandidateData.candidate = candidate;
         } else if (candidate.candidate) {
            iceCandidateData.candidate = {
               sdpMid: candidate.sdpMid || "0",
               sdpMLineIndex: candidate.sdpMLineIndex || 0,
               candidate: candidate.candidate,
            };
         } else {
            iceCandidateData.candidate = {
               sdpMid: "0",
               sdpMLineIndex: 0,
               candidate: JSON.stringify(candidate),
            };
         }

         console.log(
            "‚úÖ DEBUG: Final old ICE candidate structure:",
            JSON.stringify(iceCandidateData.candidate),
         );
      }

      const delivered = sendToUser(
         toUserId,
         "webrtc_ice_candidate",
         iceCandidateData,
      );

      if (delivered) {
         console.log(`‚úÖ ICE candidate delivered to ${toUserId}`);
      } else {
         console.log(`‚ùå Failed to deliver ICE candidate to ${toUserId}`);
      }
   });

   // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
   socket.on("disconnect", () => {
      if (socket.userId) {
         console.log(`üî¥ User ${socket.userId} disconnected`);
         connectedUsers.delete(socket.userId);

         // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –æ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
         socket.broadcast.emit("user_disconnected", {
            userId: socket.userId,
         });

         console.log(`üìä Total connected users: ${connectedUsers.size}`);
      }
   });
});

const PORT = process.env.PORT || 3000;

server.listen(PORT, () => {
   console.log(`üöÄ Signaling server running on port ${PORT}`);
   console.log(`üí¨ File-based messaging system: ENABLED`);
   console.log(`üìû New call delivery system: ENABLED`);
   console.log(`üìû Offline call support: ENABLED`);
   console.log(`üì± Push notifications for calls: ENABLED`);
   console.log(`‚è∞ Call wait timeout: ${CALL_WAIT_TIMEOUT / 1000} seconds`);
   console.log(`üìÅ Chats storage: ${MESSAGES_DIR}`);
   console.log(`üíæ Call history: ${CALL_HISTORY_FILE}`);
   console.log(`üîë FCM tokens: ${FCM_TOKENS_FILE}`);
   console.log(`üïí Server started at: ${new Date().toISOString()}`);
   console.log("=========================================");
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ graceful shutdown
process.on("SIGINT", () => {
   console.log("üõë Shutting down server...");
   console.log(`üìä Pending calls: ${pendingCalls.size}`);
   console.log(`üíæ Saving call history and FCM tokens...`);
   saveCallHistory();
   saveFCMTokens();
   console.log("‚úÖ All data saved successfully");

   // –û—á–∏—â–∞–µ–º –≤—Å–µ —Ç–∞–π–º–µ—Ä—ã
   for (const [callId, callData] of pendingCalls.entries()) {
      if (callData.timeoutId) {
         clearTimeout(callData.timeoutId);
      }
   }

   server.close(() => {
      console.log("‚úÖ Server closed");
      process.exit(0);
   });
});